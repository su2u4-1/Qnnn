# 使用說明 / Usage
執行以下任一方法 / Run one of the following methods:

## 方法一 / Method 1
### windows
```sh
$ python ./build.py ./src -o ./temp/app.exe -a <file_name>.qn <flags>
```
### linux
```sh
$ python3 ./build.py ./src -o ./temp/app -a <file_name>.qn <flags>
```
### 我自己在測試時的指令
```sh
$ python(3) ./build.py ./src -a ./test/test3.qn -o ./temp/test3 -oa -c
```

## 方法二 / Method 2
```sh
$ g++ ./src/lexer.cpp ./src/main.cpp ./src/parser.cpp ./src/qlib.cpp -o ./temp/app.exe
$ ./temp/app.exe ./<file_name>.qn <flags>
```

# 介紹 / Introduction
`Qnnn` 是一種用於學習和嘗試編譯器開發的程式語言，並非為任何特定目的設計。  
`Qnnn` is a programming language created as an attempt to learn and experiment with compiler development, without being designed for any specific purpose.

## 項目資訊 / Project Info
- 語言名稱 / Language Name: `Qnnn`  
- 文件副檔名 / File Extension: `.qn`

## 開發環境 / Development Environment
- GCC 版本 / GCC Version: `13.2.0`  
- C++ 標準 / C++ Standard: `C++17 (201703L)`
- Python 版本 / Python Version: `3.13.2`

# 文件結構 / File Structure
```
d:\Qnnn\
├── src\                # 原始碼 / Source code
│   ├── lexer.cpp       # 詞法分析器 / Lexer
│   ├── parser.cpp      # 語法分析器 / Parser
│   ├── qlib.cpp        # 類型定義與工具函數 / Type definitions and utility functions
│   ├── main.cpp        # 主程式入口 / Main entry point
├── include\            # 標頭檔案 / Header files
│   ├── lexer.h
│   ├── parser.h
│   ├── qlib.h
├── test\               # 測試檔案 / Test files
│   ├── test_ast.json   # 測試 AST 輸出 / Test AST output
│   ├── test.ast        # 測試 AST 輸出 / Test AST output
│   ├── test<n>.qn      # 測試原始碼 / Test source code
│   ......
├── temp\               # 臨時檔案 / Temporary files
├── README.md
├── .gitignore
├── LICENSE
├── .md                 # 我自己的筆記 / My own notes
├── ast_node.txt        # AST 結構設計 / AST structure design
├── grammar.bnf         # Qnnn 語法 / Qnnn grammar
├── three-address_code.md   # 三地址碼設計 / three-address code design
├── vm.md               # 虛擬機指令設計 / virtual machine command design
├── build.py
├── format.py
```
## 說明 / Description
### build.py
`build.py` 是一個用於編譯和執行 `Qnnn` 程式的腳本，旨在簡化開發過程。  
`build.py` is a script designed for compiling and executing `Qnnn` programs, aiming to simplify the development process.  
在編譯前build.py會計算原始碼的hash，且把hash值作為資料夾名稱存於`./temp/hash/`下，如果該hash值的資料夾已存在，則會跳過編譯過程直接執行之前編譯的程式。    
Before compiling, build.py calculates the hash of the source code and uses it as a directory name under `./temp/hash/`. If a directory with that hash value already exists, the compilation process will be skipped and the previously compiled program will be executed directly.

#### 使用方式 / Usage:
```sh
$ python build.py {(<file> | <dir>)} [-i <dir>] [-o <executable file>] [-a {<arg>}]
```
- `{(<file> | <dir>)}`: 可接受一個或多個檔案或資料夾，build.py 會將資料夾中的所有檔案加入編譯，生成可執行檔並運行。  
  `{(<file> | <dir>)}`: Accepts one or more files or directories. build.py will include all files in the directories for compilation, generate an executable file and run it.
- `-a {<arg>}`: 接受一連串以空白分隔的參數，這些參數會傳遞給生成的可執行檔。  
  `-a {<arg>}`: Accepts a series of space-separated arguments, which will be passed to the generated executable file.
- `-i <dir>`: 設定include目錄，會將所有原始碼的路徑轉換成絕對路徑，並添加`-I <dir>`編譯選項。  
  `-i <dir>`: Sets the include directory, converts all source code paths to absolute paths, and adds the `-I <dir>` compilation option.
- 其他參數會作為編譯器的選項傳遞給g++。  
  Other arguments will be passed to g++ as compiler options.

### format.py
`format.py` 的原始目的是使用語法分析器生成的 AST 來重新格式化原始碼，但目前該功能尚未完善。  
因此，目前主要用於檢驗 AST 是否正確，並會內部調用 `build.py`。  
`format.py` was originally intended to reformat source code using the AST generated by the parser, but this functionality is not yet fully developed.  
As a result, it is currently used primarily to verify the correctness of the AST and internally invokes `build.py`.

#### 使用方式 / Usage:
```sh
$ python ./format.py <file> "[ident]"
```
- `<file>`: 僅接受一個以 `.qn` 為副檔名的檔案。  
  `<file>`: Accepts only one file with the `.qn` extension.  
- `"[ident]"`: 僅接受一個字串  
  `"[ident]"`: Accepts only one string.
