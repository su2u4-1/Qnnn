# 使用說明 / Usage
執行以下任一方法 / Run one of the following methods:

## 方法一 / Method 1
### windows
```sh
$ python ./build.py ./src -o ./temp/app.exe -a <file_name>.qn <flags>
```
### linux
```sh
$ python3 ./build.py ./src -o ./temp/app -a <file_name>.qn <flags>
```
### 我自己在測試時的指令
```sh
$ python(3) ./build.py ./src -g -o ./temp/app.exe -a ./test/test2.qn -o ./temp/test2 -oa -c
```

## 方法二 / Method 2
```sh
$ g++ ./src/lexer.cpp ./src/main.cpp ./src/parser.cpp ./src/qlib.cpp -o ./temp/app.exe
$ ./temp/app.exe ./<file_name>.qn <flags>
```

# 介紹 / Introduction
`Qnnn` 是一種用於學習和嘗試編譯器開發的程式語言，並非為任何特定目的設計。  
`Qnnn` is a programming language created as an attempt to learn and experiment with compiler development, without being designed for any specific purpose.

## 項目資訊 / Project Info
- 語言名稱 / Language Name: `Qnnn`  
- 文件副檔名 / File Extension: `.qn`

## 開發環境 / Development Environment
- GCC 版本 / GCC Version: `13.2.0`  
- C++ 標準 / C++ Standard: `C++17 (201703L)`
- Python 版本 / Python Version: `3.13.2`

# 文件結構 / File Structure
```
d:\Qnnn\
├── src\                # 原始碼 / Source code
│   ├── lexer.cpp       # 詞法分析器 / Lexer
│   ├── parser.cpp      # 語法分析器 / Parser
│   ├── qlib.cpp        # 類型定義與工具函數 / Type definitions and utility functions
│   ├── main.cpp        # 主程式入口 / Main entry point
├── include\            # 標頭檔案 / Header files
│   ├── lexer.h
│   ├── parser.h
│   ├── qlib.h
├── test\               # 測試檔案 / Test files
│   ├── test_ast.json   # 測試 AST 輸出 / Test AST output
│   ├── test.ast        # 測試 AST 輸出 / Test AST output
│   ├── test<n>.qn      # 測試原始碼 / Test source code
│   ......
├── temp\               # 臨時檔案 / Temporary files
├── README.md
├── .gitignore
├── LICENSE
├── .md                 # 我自己的筆記 / My own notes
├── ast_node.txt        # AST 結構設計 / AST structure design
├── grammar.bnf         # Qnnn 語法 / Qnnn grammar
├── three-address_code.md   # 三地址碼設計 / three-address code design
├── vm.md               # 虛擬機指令設計 / virtual machine command design
├── build.py
├── format.py
```
## 說明 / Description
### build.py
`build.py` 是一個用於編譯和執行 `Qnnn` 程式的腳本，旨在簡化開發過程。  
`build.py` is a script designed for compiling and executing `Qnnn` programs, aiming to simplify the development process.  
在編譯前build.py會計算原始碼的hash，且把hash值存於`./temp/hash`，如果hash計算出之值與之前一樣，則會跳過編譯過程直接執行測試    
Before compiling, build.py will calculate the hash of the source code and store the hash value in `./temp/hash`. If the hash value calculated is the same as before, the compilation process will be skipped and the test will be executed directly.

#### 使用方式 / Usage:
```sh
$ python build.py {(<file> | <dir>)} [-i <dir>] [-o <executable file>] [-a {<arg>}]
```
- `{(<file> | <dir>)}`: 可接受一個或多個檔案或資料夾，`build.py` 會將資料夾中的所有檔案加入編譯，生成指定的 `<executable file>` 並運行。  
  `{(<file> | <dir>)}`: Accepts one or more files or directories. `build.py` will include all files in the directories for compilation , generate the specified `<executable file>` and run it.
- `<args>`: 接受一連串以空白分隔的參數，這些參數會傳遞給生成的 `<executable file>`。  
  `<args>`: Accepts a series of space-separated arguments, which will be passed to the generated `<executable file>`.
- `-i <dir>`: 等同於 g++ 的 `-I` 選項，將 `<dir>` 作為 include 來源，且會將所有原始碼的路徑轉換成絕對路徑
  `-i <dir>`: Equivalent to g++'s `-I` option, except `<dir>` is used as the include source, and all source code paths are converted to absolute paths.

### format.py
`format.py` 的原始目的是使用語法分析器生成的 AST 來重新格式化原始碼，但目前該功能尚未完善。  
因此，目前主要用於檢驗 AST 是否正確，並會內部調用 `build.py`。  
`format.py` was originally intended to reformat source code using the AST generated by the parser, but this functionality is not yet fully developed.  
As a result, it is currently used primarily to verify the correctness of the AST and internally invokes `build.py`.

#### 使用方式 / Usage:
```sh
$ python ./format.py <file> "[ident]"
```
- `<file>`: 僅接受一個以 `.qn` 為副檔名的檔案。  
  `<file>`: Accepts only one file with the `.qn` extension.  
- `"[ident]"`: 僅接受一個字串  
  `"[ident]"`: Accepts only one string.
